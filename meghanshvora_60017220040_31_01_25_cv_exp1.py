# -*- coding: utf-8 -*-
"""MeghanshVora_60017220040_31/01/25_CV_Exp1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19p_m74OJ6lEVlCYQBYMdn-wkIX2jefdJ
"""

import cv2

# Read the image
image1 = cv2.imread("/content/messi.jpg")
image2 = cv2.imread("/content/football.jpg")  # Replace with your image path

from google.colab.patches import cv2_imshow

cv2_imshow(image1)



import matplotlib.pyplot as plt

# Convert BGR to RGB (for proper Matplotlib display)
image_rgb = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)

# Display image
plt.imshow(image_rgb)
plt.axis("off")  # Hide axes
plt.show()

print(f"Shape: {image1.shape}")  # (Height, Width, Channels)
print(f"Size: {image1.size}")  # Total number of pixels
print(f"Data Type: {image1.dtype}")  # Data type of image array

# Split into BGR channels
blue, green, red = cv2.split(image1)

# Display individual layers
plt.figure(figsize=(10, 3))

plt.subplot(1, 3, 1)
plt.imshow(blue, cmap="Blues")
plt.title("Blue Channel")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.imshow(green, cmap="Greens")
plt.title("Green Channel")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.imshow(red, cmap="Reds")
plt.title("Red Channel")
plt.axis("off")

plt.show()

gray_image = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)

# Display grayscale image
plt.imshow(gray_image, cmap="gray")
plt.axis("off")
plt.show()

# Define cropping coordinates (y1:y2, x1:x2)
cropped_image = image1[50:300, 100:400]  # Modify coordinates as needed

# Display cropped image
plt.imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.show()

import numpy as np

# Increase brightness
bright_image = cv2.add(image1, np.array([50.0]))  # Add intensity

# Decrease brightness
dark_image = cv2.subtract(image1, np.array([50.0]))  # Subtract intensity

# Display results
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.imshow(cv2.cvtColor(bright_image, cv2.COLOR_BGR2RGB))
plt.title("Brighter Image")
plt.axis("off")

plt.subplot(1, 2, 2)
plt.imshow(cv2.cvtColor(dark_image, cv2.COLOR_BGR2RGB))
plt.title("Darker Image")
plt.axis("off")

plt.show()

import cv2
import matplotlib.pyplot as plt


# Check if the image is loaded properly
if image1 is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Superimpose the image on itself with 50% transparency
    superimposed = cv2.addWeighted(image1, 0.5, image1, 0.5, 0)

    # Convert BGR to RGB for proper display with plt
    image1_rgb = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)
    superimposed_rgb = cv2.cvtColor(superimposed, cv2.COLOR_BGR2RGB)

    # Display images using matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(image1_rgb)
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(superimposed_rgb)
    plt.title("Superimposed Image")
    plt.axis("off")

    plt.show()

import cv2
import matplotlib.pyplot as plt

# Read the images


# Check if both images are loaded properly
if image1 is None:
    print(f"Error: Unable to load image at {image_path1}")
elif image2 is None:
    print(f"Error: Unable to load image at {image_path2}")
else:
    # Resize images to the same dimensions (if necessary)
    if image1.shape != image2.shape:
        image2 = cv2.resize(image2, (image1.shape[1], image1.shape[0]))

    # Superimpose image1 on image2 with 50% transparency
    superimposed = cv2.addWeighted(image1, 0.5, image2, 0.5, 0)

    # Convert BGR to RGB for proper display with plt
    image1_rgb = cv2.cvtColor(image1, cv2.COLOR_BGR2RGB)
    image2_rgb = cv2.cvtColor(image2, cv2.COLOR_BGR2RGB)
    superimposed_rgb = cv2.cvtColor(superimposed, cv2.COLOR_BGR2RGB)

    # Display images using matplotlib
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 3, 1)
    plt.imshow(image1_rgb)
    plt.title("Image 1")
    plt.axis("off")

    plt.subplot(1, 3, 2)
    plt.imshow(image2_rgb)
    plt.title("Image 2")
    plt.axis("off")

    plt.subplot(1, 3, 3)
    plt.imshow(superimposed_rgb)
    plt.title("Superimposed Image")
    plt.axis("off")

    plt.show()

# Split into BGR channels
blue, green, red = cv2.split(image2)

# Display individual layers
plt.figure(figsize=(10, 3))

plt.subplot(1, 3, 1)
plt.imshow(blue, cmap="Blues")
plt.title("Blue Channel")
plt.axis("off")

plt.subplot(1, 3, 2)
plt.imshow(green, cmap="Greens")
plt.title("Green Channel")
plt.axis("off")

plt.subplot(1, 3, 3)
plt.imshow(red, cmap="Reds")
plt.title("Red Channel")
plt.axis("off")

plt.show()

import cv2
import numpy as np

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Define the transformation matrix for flipping horizontally
    m = np.float32([[-1, 0, cols], [0, 1, 0]])  # Horizontal flip (flip along the Y-axis)

    # Apply the affine transformation (flip the image)
    flipped_img = cv2.warpAffine(img, m, (cols, rows))

    # Convert BGR to RGB for proper display with plt
    flipped_img_rgb = cv2.cvtColor(flipped_img, cv2.COLOR_BGR2RGB)

    # Display the original and flipped images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(flipped_img_rgb)
    plt.title("Flipped Image")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Define the transformation matrix for flipping vertically
    m = np.float32([[1, 0, 0], [0, -1, rows]])  # Vertical flip (flip along the X-axis)

    # Apply the affine transformation (flip the image vertically)
    flipped_img = cv2.warpAffine(img, m, (cols, rows))

    # Convert BGR to RGB for proper display with plt
    flipped_img_rgb = cv2.cvtColor(flipped_img, cv2.COLOR_BGR2RGB)

    # Display the original and flipped images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(flipped_img_rgb)
    plt.title("Flipped Image")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Define the transformation matrix for flipping both horizontally and vertically
    m = np.float32([[-1, 0, cols], [0, -1, rows]])  # Horizontal and Vertical flip

    # Apply the affine transformation (flip the image both horizontally and vertically)
    flipped_img = cv2.warpAffine(img, m, (cols, rows))

    # Convert BGR to RGB for proper display with plt
    flipped_img_rgb = cv2.cvtColor(flipped_img, cv2.COLOR_BGR2RGB)

    # Display the original and flipped images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(flipped_img_rgb)
    plt.title("Flipped Image")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Define the transformation matrix for flipping horizontally
    m = np.float32([[1, 0, 100], [0, 1, 50]])

    # Apply the affine transformation (flip the image)
    flipped_img = cv2.warpAffine(img, m, (cols, rows))

    # Convert BGR to RGB for proper display with plt
    flipped_img_rgb = cv2.cvtColor(flipped_img, cv2.COLOR_BGR2RGB)

    # Display the original and flipped images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(flipped_img_rgb)
    plt.title("Image Translation")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Define the shear matrix (shear in X and Y direction)
    # For example: Shear X by 0.5 and Shear Y by 0.5
    shear_matrix = np.float32([[1, 0.5, 0], [0.5, 1, 0]])  # Horizontal and Vertical Shear

    # Apply the affine transformation (shear the image)
    sheared_img = cv2.warpAffine(img, shear_matrix, (cols, rows))

    # Convert BGR to RGB for proper display with plt
    sheared_img_rgb = cv2.cvtColor(sheared_img, cv2.COLOR_BGR2RGB)

    # Display the original and sheared images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(sheared_img_rgb)
    plt.title("Sheared Image")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Shear matrix: Apply shear in the Y-direction by 0.5
    shear_matrix = np.float32([[1, 0, 0], [0.5, 1, 0], [0, 0, 1]])  # Y-shear

    # Apply the affine transformation (shear the image)
    sheared_img = cv2.warpAffine(img, shear_matrix[:2], (cols, rows))  # Use only 2x3 matrix for warpAffine

    # Convert BGR to RGB for proper display with plt
    sheared_img_rgb = cv2.cvtColor(sheared_img, cv2.COLOR_BGR2RGB)

    # Display the original and sheared images using Matplotlib
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(sheared_img_rgb)
    plt.title("Sheared Image")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Shear matrix: Apply shear in the Y-direction by 0.5 (adjust this value as necessary)
    shear_matrix = np.float32([[1, 0.5, 0], [0.5, 1, 0]])  # Y-shear

    # Calculate the new dimensions after the shear to avoid cropping
    new_cols = int(cols + 0.5 * rows)  # Width increases with shear
    new_rows = rows + int(0.5 * cols)  # Height may also increase with shear

    # Apply the affine transformation (shear the image)
    sheared_img = cv2.warpAffine(img, shear_matrix, (new_cols, new_rows))

    # Convert BGR to RGB for proper display with plt
    sheared_img_rgb = cv2.cvtColor(sheared_img, cv2.COLOR_BGR2RGB)

    # Display the original and sheared images using Matplotlib
    plt.figure(figsize=(15, 7))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(sheared_img_rgb)
    plt.title("Sheared Image (Full View)")
    plt.axis("off")

    plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt

# Read the image
image_path = "/content/messi.jpg"  # Replace with your image path
img = cv2.imread(image_path)

# Check if the image is loaded properly
if img is None:
    print(f"Error: Unable to load image at {image_path}")
else:
    # Get image dimensions
    rows, cols = img.shape[:2]

    # Apply Shear (Y-direction by 0.5)
    shear_matrix = np.float32([[1, 0.5, 0], [0.5, 1, 0]])  # Y-shear

    # Calculate new dimensions after shear to avoid cropping
    new_cols = int(cols + 0.5 * rows)  # Width increases with shear
    new_rows = rows + int(0.5 * cols)  # Height may also increase with shear

    # Apply the affine transformation (shear the image)
    sheared_img = cv2.warpAffine(img, shear_matrix, (new_cols, new_rows))

    # Define the center of the image for rotation
    center = (new_cols // 2, new_rows // 2)

    # Define the rotation matrix (30 degrees)
    M = cv2.getRotationMatrix2D(center, 30, 1)  # 30 degrees rotation, scale factor = 1

    # Apply the affine transformation (rotate the sheared image)
    rotated_sheared_img = cv2.warpAffine(sheared_img, M, (new_cols, new_rows))

    # Convert BGR to RGB for proper display with plt
    rotated_sheared_img_rgb = cv2.cvtColor(rotated_sheared_img, cv2.COLOR_BGR2RGB)

    # Display the original and final transformed images using Matplotlib
    plt.figure(figsize=(15, 7))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title("Original Image")
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.imshow(rotated_sheared_img_rgb)
    plt.title("Sheared & Rotated Image (30 degrees)")
    plt.axis("off")

    plt.show()



